%include {
/*--------------------------------*- C++ -*----------------------------------*\
  =========                 |
  \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox
   \\    /   O peration     |
    \\  /    A nd           | Copyright (C) 2019 OpenCFD Ltd.
     \\/     M anipulation  |
-------------------------------------------------------------------------------
License
    This file is part of OpenFOAM.

    OpenFOAM is free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
    for more details.

    You should have received a copy of the GNU General Public License
    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.

Description
    Lemon grammar of a simple string to scalar evaluation.

    The generated parser is localized in an anonymous namespace.
    Interface code wrapping is near the bottom of the file.

\*---------------------------------------------------------------------------*/

#include "evalStringToScalarDriver.H"
#include "evalStringToScalarParser.H"
#include "unitConversion.H"
#include "Random.H"
#include "error.H"

#pragma GCC diagnostic ignored "-Wold-style-cast"
#pragma GCC diagnostic ignored "-Wunused-function"
#pragma GCC diagnostic ignored "-Wunused-variable"
#pragma GCC diagnostic ignored "-Wsign-compare"
}

%namespace      {}

// Use extra argument for the return value
%extra_context  { Foam::parsing::evalStringToScalar::parseDriver* driver }
%parse_failure  { driver->reportFatal("Parse failure, giving up..."); }
%syntax_error   { driver->reportFatal("Syntax error"); }

%token_prefix TOK_

%token_type     { Foam::scalar }

%left PLUS MINUS.
%left TIMES DIVIDE.
%left NEGATE.


eval(lhs) ::= exp(a).
{
    lhs = a;
    driver->setValue(lhs);
}

exp(lhs) ::= NUMBER(a).
{
    lhs = a;
}

exp(lhs) ::= MINUS exp(a).
{
    lhs = -a;
}

exp(lhs) ::= exp(a) PLUS exp(b).
{
    lhs = a + b;
}

exp(lhs) ::= exp(a) MINUS exp(b).
{
    lhs = a - b;
}

exp(lhs) ::= exp(a) TIMES exp(b).
{
    lhs = a * b;
}

exp(lhs) ::= exp(a) DIVIDE exp(b).
{
    lhs = a / b;
}

exp(lhs) ::= LPAREN exp(a) RPAREN.
{
    lhs = a;
}


// Functions

exp(lhs) ::= PI LPAREN RPAREN.
{
    lhs = Foam::constant::mathematical::pi;
}

exp(lhs) ::= DEG_TO_RAD LPAREN RPAREN.
{
    lhs = Foam::degToRad();
}

exp(lhs) ::= RAD_TO_DEG LPAREN RPAREN.
{
    lhs = Foam::radToDeg();
}

exp(lhs) ::= DEG_TO_RAD LPAREN exp(a) RPAREN.
{
    lhs = Foam::degToRad(a);
}

exp(lhs) ::= RAD_TO_DEG LPAREN exp(a) RPAREN.
{
    lhs = Foam::radToDeg(a);
}

exp(lhs) ::= EXP LPAREN exp(a) RPAREN.
{
    lhs = Foam::exp(a);
}

exp(lhs) ::= LOG LPAREN exp(a) RPAREN.
{
    lhs = Foam::log(a);
}

exp(lhs) ::= LOG10 LPAREN exp(a) RPAREN.
{
    lhs = Foam::log10(a);
}

exp(lhs) ::= POW LPAREN exp(a) COMMA exp(b) RPAREN.
{
    lhs = Foam::pow(a, b);
}

exp(lhs) ::= SQR LPAREN exp(a) RPAREN.
{
    lhs = Foam::sqr(a);
}

exp(lhs) ::= SQRT LPAREN exp(a) RPAREN.
{
    lhs = Foam::sqrt(a);
}

exp(lhs) ::= CBRT LPAREN exp(a) RPAREN.
{
    lhs = Foam::cbrt(a);
}

exp(lhs) ::= SIN LPAREN exp(a) RPAREN.
{
    lhs = Foam::sin(a);
}

exp(lhs) ::= COS LPAREN exp(a) RPAREN.
{
    lhs = Foam::cos(a);
}

exp(lhs) ::= TAN LPAREN exp(a) RPAREN.
{
    lhs = Foam::tan(a);
}

exp(lhs) ::= ASIN LPAREN exp(a) RPAREN.
{
    lhs = Foam::asin(a);
}

exp(lhs) ::= ACOS LPAREN exp(a) RPAREN.
{
    lhs = Foam::acos(a);
}

exp(lhs) ::= ATAN LPAREN exp(a) RPAREN.
{
    lhs = Foam::atan(a);
}

exp(lhs) ::= ATAN2 LPAREN exp(a) COMMA exp(b) RPAREN.
{
    lhs = Foam::atan2(a, b);
}

exp(lhs) ::= HYPOT LPAREN exp(a) COMMA exp(b) RPAREN.
{
    lhs = Foam::hypot(a, b);
}

exp(lhs) ::= SINH LPAREN exp(a) RPAREN.
{
    lhs = Foam::sinh(a);
}

exp(lhs) ::= COSH LPAREN exp(a) RPAREN.
{
    lhs = Foam::cosh(a);
}

exp(lhs) ::= TANH LPAREN exp(a) RPAREN.
{
    lhs = Foam::tanh(a);
}

exp(lhs) ::= MIN LPAREN exp(a) COMMA exp(b) RPAREN.
{
    lhs = Foam::min(a, b);
}

exp(lhs) ::= MAX LPAREN exp(a) COMMA exp(b) RPAREN.
{
    lhs = Foam::max(a, b);
}

exp(lhs) ::= MAG LPAREN exp(a) RPAREN.
{
    lhs = Foam::mag(a);
}

exp(lhs) ::= MAGSQR LPAREN exp(a) RPAREN.
{
    lhs = Foam::magSqr(a);
}

exp(lhs) ::= FLOOR LPAREN exp(a) RPAREN.
{
    lhs = std::floor(a);
}

exp(lhs) ::= CEIL LPAREN exp(a) RPAREN.
{
    lhs = std::ceil(a);
}

exp(lhs) ::= ROUND LPAREN exp(a) RPAREN.
{
    lhs = std::round(a);
}

exp(lhs) ::= RAND LPAREN RPAREN.
{
    lhs = Foam::Random().sample01<Foam::scalar>();
}

exp(lhs) ::= RAND LPAREN exp(seed) RPAREN.
{
    lhs = Foam::Random(seed).sample01<Foam::scalar>();
}


// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

%code
{

// * * * * * * * * * * * * * * * Member Functions  * * * * * * * * * * * * * //

void Foam::parsing::evalStringToScalar::parser::stop()
{
    if (lemon_)
    {
        ParseFree(lemon_, ::operator delete);
        lemon_ = nullptr;
    }
}


void Foam::parsing::evalStringToScalar::parser::start(parseDriver& driver)
{
    this->stop();
    lemon_ = ParseAlloc(::operator new, &driver);
}


void Foam::parsing::evalStringToScalar::parser::parse
(
    int tokenId,
    Foam::scalar val    /* The value for the token */
)
{
    Parse(lemon_, tokenId, val);
}


// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

}  // Code


// ************************************************************************* //
